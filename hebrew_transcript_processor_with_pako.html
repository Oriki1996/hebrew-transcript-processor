<!doctype html>
<html lang="he" dir="rtl">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>××¢×‘×“ ×ª××œ×™×œ×™× ××§×“××™</title>
<style>
/* â”€â”€ CREAM & STARS THEME â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
:root{
  --bg:#faf7f0;--surface:#fffef8;--card:#fff9ee;
  --border:rgba(160,130,50,0.18);--shadow:0 2px 14px rgba(120,90,20,0.07);
  --fg:#261c0a;--muted:#7a6a4a;--accent:#7a5c1e;--gold:#c09830;--orange:#b86010;
}
/* â”€â”€ DARK ACADEMIA THEME â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.dark-theme{
  --bg:#1c1a2e;--surface:#17162b;--card:#1f1c3a;
  --border:rgba(160,130,50,0.22);--shadow:0 2px 14px rgba(0,0,0,0.45);
  --fg:#e8dfc8;--muted:#9a8f72;--accent:#d4a84b;
  /* --gold, --orange unchanged â€” gold accents stay gold */
}
.dark-theme body{background-color:var(--bg)}
.dark-theme .settings-bar{background:rgba(23,21,43,0.92)}
*{box-sizing:border-box}
html,body{height:100%;margin:0;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans Hebrew","Heebo",sans-serif;background:var(--bg);color:var(--fg);direction:rtl}
/* Star tiled background â€” 5-pointed polygon, ~4.5% gold opacity */
body{
  background-color:var(--bg);
  background-image:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='80' height='80'%3E%3Cpolygon points='40,16 45.88,31.91 62.83,32.58 49.51,43.09 54.11,59.42 40,50 25.89,59.42 30.49,43.09 17.17,32.58 34.12,31.91' fill='%23c09830' fill-opacity='0.045'/%3E%3C/svg%3E");
}
.app{display:flex;flex-direction:column;min-height:100vh}

/* â”€â”€ HEADER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
header{background:var(--surface);border-bottom:1px solid var(--border);box-shadow:var(--shadow)}
.header-top{display:flex;align-items:center;justify-content:space-between;padding:13px 22px;gap:12px}
.header-title{font-size:17px;font-weight:700;color:var(--accent);letter-spacing:0.3px;white-space:nowrap}
.header-title::before{content:'âœ¦ ';color:var(--gold)}
.settings-toggle{background:transparent;border:1px solid var(--border);padding:6px 14px;border-radius:6px;color:var(--muted);cursor:pointer;font-size:13px;transition:all .2s}
.settings-toggle:hover{border-color:var(--gold);color:var(--accent)}
/* Settings bar â€” hidden by default, toggled open */
.settings-bar{display:none;padding:12px 22px 15px;border-top:1px solid var(--border);background:rgba(255,252,240,0.85);gap:14px;flex-wrap:wrap;align-items:center}
.settings-bar.open{display:flex}
.field-grp{display:flex;align-items:center;gap:8px;flex:1;min-width:210px}
label.lbl{font-size:12px;color:var(--muted);white-space:nowrap;font-weight:500}
input.api-in{background:var(--bg);border:1px solid var(--border);color:var(--fg);padding:7px 10px;border-radius:6px;font-size:13px;flex:1;min-width:0;transition:border .2s}
input.api-in:focus{outline:none;border-color:var(--gold)}
.btn-ghost{background:transparent;border:1px solid var(--border);padding:6px 10px;border-radius:6px;color:var(--muted);cursor:pointer;font-size:12px;white-space:nowrap;transition:all .2s}
.btn-ghost:hover{border-color:var(--gold);color:var(--accent)}
select.model-sel{background:var(--bg);border:1px solid var(--border);color:var(--fg);padding:7px 10px;border-radius:6px;font-size:13px;cursor:pointer;direction:rtl}
select.model-sel:focus{outline:none;border-color:var(--gold)}
.provider-tag{font-size:11px;padding:3px 10px;border-radius:4px;white-space:nowrap;background:rgba(192,152,48,0.1);border:1px solid rgba(192,152,48,0.22);color:var(--accent);font-weight:500}

/* â”€â”€ MAIN LAYOUT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
main{flex:1;padding:28px 22px;max-width:920px;width:100%;margin:0 auto}
.screen{display:none}.screen.active{display:block}

/* â”€â”€ SECTION TITLES â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.section-title{font-size:21px;font-weight:700;margin-bottom:16px;color:var(--fg);display:flex;align-items:center;gap:8px}
.section-title::before{content:'âœ¦';color:var(--gold);font-size:13px;flex-shrink:0}

/* â”€â”€ INPUT SCREEN â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
textarea#raw{width:100%;height:38vh;background:var(--surface);border:1px solid var(--border);color:var(--fg);padding:16px;border-radius:12px;resize:vertical;direction:rtl;font-size:15px;line-height:1.7;font-family:inherit;box-shadow:inset 0 1px 4px rgba(120,90,20,0.04);transition:border .2s}
textarea#raw:focus{outline:none;border-color:var(--gold)}
textarea#raw::placeholder{color:var(--muted)}
.uploads{display:flex;gap:10px;margin-top:12px;flex-wrap:wrap}
.btn-upload{background:rgba(192,152,48,0.07);border:1px solid rgba(192,152,48,0.22);color:var(--accent);padding:9px 16px;border-radius:8px;cursor:pointer;font-size:14px;font-weight:500;transition:all .2s}
.btn-upload:hover{background:rgba(192,152,48,0.15);border-color:var(--gold)}
.file-info{color:var(--muted);font-size:13px;margin-top:8px;min-height:18px}
.btn-main{background:var(--accent);color:#fffef0;border:none;padding:12px 28px;border-radius:10px;font-size:15px;font-weight:600;cursor:pointer;margin-top:16px;letter-spacing:0.3px;transition:all .2s}
.btn-main:hover{background:var(--gold);box-shadow:0 4px 18px rgba(192,152,48,0.28)}
.btn-secondary{background:rgba(120,90,20,0.05);border:1px solid var(--border);color:var(--fg);padding:10px 20px;border-radius:8px;font-size:14px;cursor:pointer;transition:all .2s}
.btn-secondary:hover{border-color:var(--gold);background:rgba(192,152,48,0.07)}

/* â”€â”€ IDENT SCREEN â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.ident-card{background:var(--card);border:1px solid var(--border);border-radius:14px;padding:24px;margin-bottom:16px;box-shadow:var(--shadow)}
.big-type{font-size:21px;font-weight:700;color:var(--accent);margin-bottom:8px}
.parts-info{color:var(--muted);font-size:15px;margin-bottom:10px}
.warning-text{color:var(--orange);font-size:14px;margin-bottom:10px;font-weight:500}
select.override{background:var(--bg);border:1px solid var(--border);color:var(--fg);padding:8px 12px;border-radius:8px;font-size:14px;margin-bottom:16px;direction:rtl}
select.override:focus{outline:none;border-color:var(--gold)}
.ident-actions{display:flex;gap:10px;flex-wrap:wrap}

/* â”€â”€ PROCESS SCREEN â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.process-wrap{text-align:center;padding:60px 0}
.star-anim{display:inline-block;font-size:38px;color:var(--gold);animation:starPulse 2.4s ease-in-out infinite;margin-bottom:22px}
@keyframes starPulse{0%,100%{transform:rotate(0deg) scale(1);opacity:.9}50%{transform:rotate(180deg) scale(1.18);opacity:1}}
.progress-outer{height:7px;background:rgba(120,90,20,0.1);border-radius:8px;overflow:hidden;margin:24px auto;max-width:480px}
.progress-inner{height:100%;background:linear-gradient(90deg,var(--accent),var(--gold));width:0%;transition:width .4s;border-radius:8px}
.status-msg{color:var(--muted);font-size:15px;margin-top:10px}
.part-indicator{color:var(--accent);font-size:14px;margin-top:6px;font-weight:500}

/* â”€â”€ OUTPUT SCREEN â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.output-actions{display:flex;gap:10px;flex-wrap:wrap;margin-bottom:16px}
.stats-bar{color:var(--muted);font-size:13px;margin:0 0 14px;padding:10px 14px;background:rgba(192,152,48,0.05);border-radius:8px;border:1px solid var(--border)}
.output-box{background:var(--surface);border:1px solid var(--border);border-radius:14px;padding:28px;overflow:auto;line-height:1.85;font-size:15px;box-shadow:var(--shadow)}
.output-box h1{font-size:23px;color:var(--fg);border-bottom:2px solid var(--gold);padding-bottom:10px;margin-top:0}
.output-box h2{font-size:19px;color:var(--fg);margin-top:28px;margin-bottom:8px;padding-right:12px;border-right:3px solid var(--gold)}
.output-box h3{font-size:16px;color:var(--muted);margin-top:18px;margin-bottom:6px}
.output-box p{margin:0 0 14px 0}
.bracket{color:var(--orange);font-weight:500}
</style>
</head>
<body>
<div class="app">

<header>
  <div class="header-top">
    <div class="header-title">××¢×‘×“ ×ª××œ×™×œ×™× ××§×“××™</div>
    <div style="display:flex;gap:8px">
      <button id="themeToggle" class="settings-toggle">ğŸŒ™</button>
      <button id="settingsToggle" class="settings-toggle">âš™ ×”×’×“×¨×•×ª</button>
    </div>
  </div>
  <div id="settingsBar" class="settings-bar">
    <div class="field-grp">
      <label class="lbl">Anthropic Key</label>
      <input id="apiKey" class="api-in" type="password" placeholder="sk-ant-..." />
      <button id="toggleKey" class="btn-ghost">×”×¦×’</button>
    </div>
    <div class="field-grp">
      <label class="lbl">Gemini Key</label>
      <input id="geminiKey" class="api-in" type="password" placeholder="AIza..." />
      <button id="toggleGeminiKey" class="btn-ghost">×”×¦×’</button>
    </div>
    <div class="field-grp" style="flex:0;min-width:auto;gap:8px">
      <label class="lbl">××•×“×œ</label>
      <select id="modelSelect" class="model-sel">
        <option value="claude-3-5-sonnet-20241022">Claude 3.5 Sonnet</option>
        <option value="claude-3-opus-20240229">Claude 3 Opus</option>
        <option value="claude-3-5-haiku-20241022">Claude 3.5 Haiku</option>
        <option value="gemini-2.5-pro">Gemini 2.5 Pro</option>
        <option value="gemini-2.0-flash">Gemini 2.0 Flash</option>
        <option value="gemini-1.5-pro">Gemini 1.5 Pro</option>
        <option value="gemini-1.5-flash">Gemini 1.5 Flash</option>
      </select>
      <div id="providerTag" class="provider-tag">Anthropic</div>
    </div>
  </div>
</header>

<main>
  <!-- SCREEN 1: INPUT -->
  <div id="screen-input" class="screen active">
    <div class="section-title">××¢×‘×“ ×ª××œ×™×œ×™× ××§×“××™</div>
    <textarea id="raw" placeholder="×”×“×‘×§ ×›××Ÿ ××ª ×”×ª××œ×™×œ ×”×’×•×œ××™..."></textarea>
    <div class="uploads">
      <label class="btn-upload">×”×¢×œ×” TXT<input id="fileTxt" type="file" accept=".txt" style="display:none"></label>
      <label class="btn-upload">×”×¢×œ×” Word/PDF<input id="fileOther" type="file" accept=".docx,.pdf,.txt" style="display:none"></label>
    </div>
    <div id="fileInfo" class="file-info"></div>
    <div><button id="identifyBtn" class="btn-main">×–×”×” ×¡×•×’ ×•×¢×‘×“ â†</button></div>
  </div>

  <!-- SCREEN 2: IDENTIFICATION -->
  <div id="screen-ident" class="screen">
    <div class="section-title">×–×™×”×•×™ ×”×ª××œ×™×œ</div>
    <div class="ident-card">
      <div id="detectedType" class="big-type">×× ×ª×—...</div>
      <div id="recommendedParts" class="parts-info"></div>
      <div id="identWarning" class="warning-text"></div>
      <select id="manualOverride" class="override">
        <option value="auto">×–×™×”×•×™ ××•×˜×•××˜×™</option>
        <option value="×”×¨×¦××” ××§×“××™×ª">×”×¨×¦××” ××§×“××™×ª</option>
        <option value="×™×©×™×‘×ª ×¢×‘×•×“×”">×™×©×™×‘×ª ×¢×‘×•×“×”</option>
        <option value="×¨××™×•×Ÿ">×¨××™×•×Ÿ</option>
        <option value="×¤×× ×œ">×¤×× ×œ</option>
      </select>
      <div class="ident-actions">
        <button id="confirmStart" class="btn-main">××©×¨ ×•×”×ª×—×œ ×¢×™×‘×•×“ â†</button>
        <button id="resetBtn" class="btn-secondary">×”×ª×—×œ ××—×“×©</button>
      </div>
    </div>
  </div>

  <!-- SCREEN 3: PROCESSING -->
  <div id="screen-process" class="screen">
    <div class="process-wrap">
      <div class="section-title" style="justify-content:center">××¢×‘×“ ×ª××œ×™×œ</div>
      <div class="star-anim">âœ¦</div>
      <div class="progress-outer"><div id="progressBar" class="progress-inner"></div></div>
      <div id="statusMsg" class="status-msg">××ª×—×™×œ ×¢×™×‘×•×“...</div>
      <div id="partIndicator" class="part-indicator"></div>
    </div>
  </div>

  <!-- SCREEN 4: OUTPUT -->
  <div id="screen-output" class="screen">
    <div class="section-title">×ª××œ×™×œ ××¢×•×‘×“</div>
    <div class="output-actions">
      <button id="copyAll" class="btn-main">×”×¢×ª×§ ×”×›×œ</button>
      <button id="exportTxt" class="btn-secondary">×™×™×¦× ×›-TXT</button>
      <button id="exportDoc" class="btn-secondary">×™×™×¦× ×œ-Word</button>
      <button id="newProcess" class="btn-secondary">×¢×™×‘×•×“ ×—×“×©</button>
    </div>
    <div id="statsBar" class="stats-bar"></div>
    <div id="outputArea" class="output-box"></div>
  </div>
</main>
</div>

<script>
const SYSTEM_PROMPT = `×ª×¤×§×™×“
××ª×” ×¢×•×¨×š ××§×“××™ ×•××§×¦×•×¢×™ ×‘×›×™×¨ ×”××ª××—×” ×‘×”×¤×™×›×ª ×ª××œ×•×œ×™× ×’×•×œ××™×™× ×œ××¡××›×™× ××¢×•×‘×“×™× ×•××™×›×•×ª×™×™×. ×ª×¤×§×™×“×š ×œ×—×œ×¥ ××ª ×”×ª×•×›×Ÿ ×”××”×•×ª×™ ××ª×•×š ×”×©×¤×” ×”××“×•×‘×¨×ª, ×œ××¨×’×Ÿ ××•×ª×• ×‘××‘× ×” ×œ×•×’×™, ×•×œ×”×¦×™×’ ××•×ª×• ×‘×›×ª×™×‘×” ×¨×”×•×˜×” ×”××•×ª×××ª ×œ×¡×•×’ ×”×—×•××¨ ×•×œ××˜×¨×ª×•.

×©×œ×‘ ××§×“×™× ×—×•×‘×”: ×–×™×”×•×™ ×•× ×™×ª×•×‘
×œ×¤× ×™ ×ª×—×™×œ×ª ×”×¢×™×‘×•×“, ×¢×œ×™×š ×œ×–×”×•×ª ××ª ×¡×•×’ ×”×ª××œ×•×œ ×•×œ×”×•×“×™×¢ ×œ××©×ª××©. ×¡×•×’×™ ×”×ª××œ×•×œ×™× ×”××¤×©×¨×™×™× ×”× ×”×¨×¦××” ××§×“××™×ª, ×™×©×™×‘×ª ×¢×‘×•×“×” ××• ×¦×•×•×ª, ×¨××™×•×Ÿ ××• ×©×™×—×”, ×•×¤×× ×œ ××• ×“×™×•×Ÿ ××¨×•×‘×” ××©×ª×ª×¤×™×. ×œ××—×¨ ×”×–×™×”×•×™, ×¢×œ×™×š ×œ×”×¢×¨×™×š ××ª ×”×™×§×£ ×”×—×•××¨ ×•×œ×”×•×“×™×¢ ×œ××©×ª××© ×‘×›××” ×—×œ×§×™× ×ª×¦×˜×¨×š ×œ×¢×‘×“ ××•×ª×• ×›×“×™ ×œ×©××•×¨ ×¢×œ ××™×›×•×ª ××œ××” ×œ×œ× ×ª××¦×•×ª ××• ×”×©××˜×•×ª. ×× ×™×•×ª×¨ ×-20% ××”×ª××œ×•×œ ××™× ×• × ×™×ª×Ÿ ×œ×©×—×–×•×¨, ×™×© ×œ×”×•×“×™×¢ ×œ××©×ª××© ×œ×¤× ×™ ×”×¢×™×‘×•×“ ×•×œ×©××•×œ ×× ×œ×”××©×™×š. ×”××©×š ×œ×¢×™×‘×•×“ ×¨×§ ×œ××—×¨ ××™×©×•×¨ ×”××©×ª××©.

××¡×œ×•×œ ×: ×”×¨×¦××” ××§×“××™×ª

×¢×§×¨×•× ×•×ª ×™×¡×•×“

××™×§×•×“ ×‘×§×•×œ ×”××¨×¦×”. ×”×ª×•×›×Ÿ ×”××¨×›×–×™ ×”×•× ×“×‘×¨×™ ×”××¨×¦×”. ×©××œ×•×ª ×¡×˜×•×“× ×˜×™×, ×”×¢×¨×•×ª ××’×‘ ×•×“×™×•× ×™× ×§×¦×¨×™× ××™× × ×—×œ×§ ××”×ª×•×¦×¨ ×”×¡×•×¤×™, ××œ× ×× ×”××¨×¦×” ×‘×—×¨ ×œ×”×¨×—×™×‘ ×‘×ª×©×•×‘×ª×• ×‘××•×¤×Ÿ ××©××¢×•×ª×™ â€” ×‘××§×¨×” ×›×–×” ×™×© ×œ×©×œ×‘ ××ª ×ª×•×›×Ÿ ×”×”×¡×‘×¨ ×›×—×œ×§ ××•×¨×’× ×™ ××”×˜×§×¡×˜, ×œ×œ× ×¦×™×•×Ÿ ×©××“×•×‘×¨ ×‘×ª×©×•×‘×” ×œ×©××œ×”.

×”×¡×¨×ª ×’×•×£ ×¨××©×•×Ÿ. ×“×‘×¨×™ ×”××¨×¦×” ×œ× ×™×•×¤×™×¢×• ×‘×’×•×£ ×¨××©×•×Ÿ ×•×œ× ×™×¦×•×˜×˜×• ×›"×”××¨×¦×” ×××¨". ×”×˜×§×¡×˜ ×™×™×›×ª×‘ ×›××©×¤×˜×™× ×¢×¦×××™×™× ×‘×’×•×£ ×©×œ×™×©×™. ×œ×¢×•××ª ×–××ª, ×›××©×¨ ××•×–×›×¨ ×”×•×’×”, ×—×•×§×¨, ×ª×™××•×¨×˜×™×§×Ÿ ××• ×‘×¢×œ ×¢××“×” ×›×œ×©×”×• â€” ×™×© ×œ×¦×™×™×Ÿ ××ª ×©××• ×•×œ×™×™×—×¡ ×œ×• ××ª ×”×¨×¢×™×•×Ÿ. ×œ××©×œ: "×¤×¨×•×™×“ ×˜×¢×Ÿ ×›×™...", "×¢×œ ×¤×™ ×•×™×’×•×¦×§×™...", "×œ×¤×™ ×’×™×©×ª×• ×©×œ ×××¨×§×¡...".

×©×œ××•×ª ××§×“××™×ª. ×›×œ ××•×©×’, ×ª×™××•×¨×™×”, ××•×“×œ, ×—×•×§×¨, ××—×§×¨, ×“×•×’××” ××• ×”×¡×‘×¨ ×©×”××¨×¦×” ×”×¦×™×’ ×—×™×™×‘ ×œ×”×•×¤×™×¢ ×‘×ª×•×¦×¨. ××™×Ÿ ×œ×”×©××™×˜ ×ª×•×›×Ÿ ××§×“××™. ××™×Ÿ ×œ×”×•×¡×™×£ ××™×“×¢ ×©×œ× × ×××¨ ×‘×”×¨×¦××”, ×’× ×× ×”×•× × ×›×•×Ÿ ×•×¨×œ×•×•× ×˜×™.

××™×¦×•×™ ××•×©×’×™×. ×‘×¡×•×£ ×›×œ ××¡××š ×™×•×¤×™×¢ ×¤×¨×§ "××•×©×’×™× ××¨×›×–×™×™×" ×”××›×™×œ ××ª ×›×œ ×”××•×©×’×™×, ×”×ª×™××•×¨×™×•×ª ×•×”×”×’×“×¨×•×ª ×©×”×•×–×›×¨×• ×‘×”×¨×¦××”. ×›×œ ××•×©×’ ×™×•×¤×™×¢ ×¢× ×”×’×“×¨×ª×• ×›×¤×™ ×©× ×™×ª× ×” ×‘×”×¨×¦××”. ×× ××•×©×’ ×”×•×–×›×¨ ××š ×œ× ×”×•×’×“×¨ ×‘×‘×™×¨×•×¨, ×™×© ×œ×¦×™×™×Ÿ: [××•×©×’ ×–×” ×”×•×–×›×¨ ×‘×”×¨×¦××” ××š ×”×’×“×¨×ª×• ××™× ×” ×‘×¨×•×¨×” ××”×ª××œ×•×œ]. ××™×Ÿ ×œ×”××¦×™× ×”×’×“×¨×•×ª ×××§×•×¨×•×ª ×—×™×¦×•× ×™×™×.

×™×™×—×•×¡ ××§×•×¨×•×ª. ×™×© ×œ×¦×™×™×Ÿ ×©××•×ª ×—×•×§×¨×™×, ××—×§×¨×™× ×•××××¨×™× ×¨×§ ×× ×”×•×–×›×¨×• ×‘××¤×•×¨×© ×‘×”×¨×¦××”. ×›××©×¨ ×”××¨×¦×” ×”×ª×™×™×—×¡ ×œ××—×§×¨ ×œ×œ× ×¦×™×•×Ÿ ×”××§×•×¨, ×™×© ×œ×©××•×¨ ×¢×œ ××•×ª×” ×¨××ª ×›×œ×œ×™×•×ª: "××—×§×¨×™× ×‘×ª×—×•× ××¦×‘×™×¢×™× ×¢×œ ×›×š ×©..." ××• "×’×™×©×” ×ª×™××•×¨×˜×™×ª ××—×ª ×’×•×¨×¡×ª ×›×™...".

×˜×™×¤×•×œ ×‘×©×¤×” ××¢×•×¨×‘×ª. ××•× ×—×™× ××§×“××™×™× ×‘×× ×’×œ×™×ª ×™×•×¤×™×¢×• ×‘×¤×•×¨××˜: ×”××•× ×— ×”×¢×‘×¨×™ (English Term) ×‘×”×•×¤×¢×” ×”×¨××©×•× ×” ×‘×œ×‘×“. ×œ××—×¨ ××›×Ÿ ×™×•×¤×™×¢ ×”××•× ×— ×‘×¢×‘×¨×™×ª ×‘×œ×‘×“. ×× ×œ× ×§×™×™× ×ª×¨×’×•× ×¢×‘×¨×™ ××§×•×‘×œ, ×™×™×©××¨ ×”××•× ×— ×‘×× ×’×œ×™×ª ×¢× ×”×¡×‘×¨ ×‘×¢×‘×¨×™×ª ×‘×¡×•×’×¨×™×™×.

×˜×™×¤×•×œ ×‘× ×ª×•× ×™× ×›××•×ª×™×™×. ××¡×¤×¨×™×, ××—×•×–×™× ×•×ª××¨×™×›×™× ×™×©××¨×• ××“×•×™×§×™× ×›×¤×™ ×©× ×××¨×•. ×× ××¡×¤×¨ ×œ× × ×©××¢ ×‘×¨×•×¨ ×‘×ª××œ×•×œ, ×™×© ×œ×¦×™×™×Ÿ: [××¡×¤×¨ ×œ× ×‘×¨×•×¨ ×‘×ª××œ×•×œ].

×¤×•×¨××˜. ×”×˜×§×¡×˜ ×™×™×›×ª×‘ ×›×¤×¨×•×–×” ×¨×¦×™×¤×” ×‘×œ×‘×“ â€” ×œ×œ× × ×§×•×“×•×ª, ×œ×œ× ×¨×©×™××•×ª, ×œ×œ× ××§×¤×™×. ×”×˜×§×¡×˜ ×™×–×¨×•× ×›×ª××œ×™×œ ×§×•× ×§×¨×˜×™ ×•×¨×¦×™×£. ××‘× ×” ×”×›×•×ª×¨×•×ª: H1 ×œ× ×•×©× ×”×”×¨×¦××”, H2 ×œ× ×•×©××™× ××¨×›×–×™×™×, H3 ×œ×ª×ª×™-× ×•×©××™×. ××•×©×’×™ ××¤×ª×— ×™×•×“×’×©×• ×‘×”×•×¤×¢×” ×”×¨××©×•× ×”. ×”×©×¤×” ×ª×”×™×” ×¢×‘×¨×™×ª ××§×“××™×ª ×ª×§× ×™×ª.

××‘× ×” ×”×ª×•×¦×¨. ×”×—×•××¨ ×™×¡×•×“×¨ ×œ×¤×™ ×”×¨×¦×£ ×”×‘×: ×¨×§×¢ ×ª×™××•×¨×˜×™ ××• ×”×™×¡×˜×•×¨×™ × ×“×¨×©, ×”×’×“×¨×•×ª ×™×¡×•×“ ×•××•×©×’×™ ×‘×¡×™×¡, ×¤×™×ª×•×— ×”×¨×¢×™×•× ×•×ª ×•×”×§×©×¨×™× ×‘×™× ×™×”×, ×“×•×’×××•×ª ×™×™×©×•××™× ×•××¡×§× ×•×ª, ×•×œ×‘×¡×•×£ ×¤×¨×§ "××•×©×’×™× ××¨×›×–×™×™×".

××¡×œ×•×œ ×‘: ×™×©×™×‘×ª ×¢×‘×•×“×” ××• ×¦×•×•×ª
××™×¤×•×™ ×§×•×œ×•×ª ×•×”×—×œ×˜×•×ª. ×™×© ×œ×–×”×•×ª ××ª ×”××©×ª×ª×¤×™× ×•×ª×¤×§×™×“×™×”×, ×œ×”×¤×¨×™×“ ×‘×™×Ÿ ×“×™×•×Ÿ ×œ×”×—×œ×˜×”, ×•×œ×©××•×¨ ××¡×¤×¨×™× ×•×ª××¨×™×›×™× ××“×•×™×§×™× â€” ×× ×œ× ×‘×¨×•×¨×™× ×™×¦×•×™×Ÿ [×œ× ×‘×¨×•×¨ ×‘×ª××œ×•×œ]. ××‘× ×”: ×¡×™×›×•× ×× ×”×œ×™×, × ×•×©××™× ×©× ×“×•× ×•, ×”×—×œ×˜×•×ª ×¢× ××—×¨××™× ×•×œ×•×—×•×ª ×–×× ×™×, × ×•×©××™× ×¤×ª×•×—×™×. ×¤×•×¨××˜: ×¤×¨×•×–×” ×œ×“×™×•× ×™×, ×¨×©×™××•×ª ×œ×”×—×œ×˜×•×ª ×•××©×™××•×ª ×‘×œ×‘×“.

××¡×œ×•×œ ×’: ×¨××™×•×Ÿ ××• ×©×™×—×”
×©×™××•×¨ ×©× ×™ ×”×§×•×œ×•×ª, ×”×‘×—× ×” ×‘×™×Ÿ ×¢×•×‘×“×•×ª ×œ×“×¢×•×ª, ×©×™×§×•×£ ×”×™×¡×•×¡×™× ×•×”×¡×ª×™×™×’×•×™×•×ª. ××‘× ×”: ×”×§×“××”, ×—×œ×•×§×” ×ª××˜×™×ª, ×¡×™×›×•×. ×¤×•×¨××˜: ×¤×¨×•×–×” ×¨×¦×™×¤×” ×¢× ×¦×™×˜×•×˜×™× ×™×©×™×¨×™× ×§×¦×¨×™× ×›×©×”× ×™×¡×•×— ×”××§×•×¨×™ ×—×©×•×‘.

××¡×œ×•×œ ×“: ×¤×× ×œ ××• ×“×™×•×Ÿ ××¨×•×‘×” ××©×ª×ª×¤×™×
××™×¤×•×™ ×¢××“×•×ª, ×”×‘×—× ×” ×‘×™×Ÿ ×”×¡×›××” ×œ××—×œ×•×§×ª, ××™×–×•×Ÿ ×™×™×¦×•×’ ×œ×¤×™ ×ª×¨×•××” ××”×•×ª×™×ª. ××‘× ×”: ×”×¦×’×ª ××©×ª×ª×¤×™×, ×”× ×•×©× ×”××¨×›×–×™, ×”×¢××“×•×ª ×”×©×•× ×•×ª, × ×§×•×“×•×ª ×”×¡×›××” ×•××—×œ×•×§×ª. ×¤×•×¨××˜: ×¤×¨×•×–×” ×¢× ×™×™×—×•×¡ ×‘×¨×•×¨, H2 ×œ× ×•×©××™×, H3 ×œ×¢××“×•×ª.

×”× ×—×™×•×ª ××©×•×ª×¤×•×ª ×œ×›×œ ×”××¡×œ×•×œ×™×
×˜×™×¤×•×œ ×‘××™-×•×“××•×ª: [×§×˜×¢ ×œ× ×‘×¨×•×¨ ×‘×ª××œ×•×œ]. × ×™×§×•×™ ×©×¤×” ××“×•×‘×¨×ª: ××—×§ ××•×§×™×™, × ×›×•×Ÿ?, ××– ×‘×¢×¦×, ×××, ×›××™×œ×•, ×™×¢× ×™, ×—×–×¨×•×ª, ×©×™×—×•×ª ×¦×“×“×™×•×ª, ×‘×“×™×—×•×ª, ×”×ª×™×™×—×¡×•×™×•×ª ×˜×›× ×™×•×ª. ×¢×§×‘×™×•×ª ×˜×¨××™× ×•×œ×•×’×™×ª ×œ××•×¨×š ×›×œ ×”××¡××š. ×›×œ ××¡××š ××¡×ª×™×™× ×‘××©×¤×˜: ×”×¡×™×›×•× ×”×•×©×œ×.

×—×©×•×‘ ×××•×“: ×”×—×–×¨ HTML ×ª×§× ×™ ×‘×œ×‘×“ ×¢× ×ª×’×™×•×ª h1, h2, h3, p, strong. ××œ ×ª×—×–×™×¨ Markdown. ××œ ×ª×•×¡×™×£ ×§×•×“ ×’×“×¨. ×¨×§ HTML × ×§×™.`;

// â”€â”€ DOM ELEMENTS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const apiKeyEl        = document.getElementById('apiKey');
const geminiKeyEl     = document.getElementById('geminiKey');
const modelSelectEl   = document.getElementById('modelSelect');
const providerTagEl   = document.getElementById('providerTag');
const settingsToggleBtn = document.getElementById('settingsToggle');
const settingsBarEl   = document.getElementById('settingsBar');
const toggleKeyBtn    = document.getElementById('toggleKey');
const toggleGeminiKeyBtn = document.getElementById('toggleGeminiKey');
const rawEl           = document.getElementById('raw');
const fileTxtEl       = document.getElementById('fileTxt');
const fileOtherEl     = document.getElementById('fileOther');
const fileInfoEl      = document.getElementById('fileInfo');
const identifyBtn     = document.getElementById('identifyBtn');
const screenInput     = document.getElementById('screen-input');
const screenIdent     = document.getElementById('screen-ident');
const screenProcess   = document.getElementById('screen-process');
const screenOutput    = document.getElementById('screen-output');
const detectedTypeEl  = document.getElementById('detectedType');
const recommendedPartsEl = document.getElementById('recommendedParts');
const manualOverrideEl   = document.getElementById('manualOverride');
const identWarningEl  = document.getElementById('identWarning');
const confirmStartBtn = document.getElementById('confirmStart');
const resetBtn        = document.getElementById('resetBtn');
const progressBar     = document.getElementById('progressBar');
const statusMsgEl     = document.getElementById('statusMsg');
const partIndicatorEl = document.getElementById('partIndicator');
const outputArea      = document.getElementById('outputArea');
const statsBarEl      = document.getElementById('statsBar');
const copyAllBtn      = document.getElementById('copyAll');
const exportTxtBtn    = document.getElementById('exportTxt');
const exportDocBtn    = document.getElementById('exportDoc');
const newProcessBtn   = document.getElementById('newProcess');
const themeToggleBtn  = document.getElementById('themeToggle');

let rawText = '';
let rotatingInterval = null;
const SCREENS = [screenInput, screenIdent, screenProcess, screenOutput];

// â”€â”€ INITIALISATION â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const savedKey = localStorage.getItem('anthropic_api_key');
if (savedKey) apiKeyEl.value = savedKey;

const savedGeminiKey = localStorage.getItem('gemini_api_key');
if (savedGeminiKey) geminiKeyEl.value = savedGeminiKey;

const savedModel = localStorage.getItem('selected_model');
if (savedModel && modelSelectEl.querySelector(`option[value="${savedModel}"]`)) {
  modelSelectEl.value = savedModel;
}
updateProviderTag();

// Auto-open settings only if no keys saved yet
if (!savedKey && !savedGeminiKey) settingsBarEl.classList.add('open');

// Dark theme restore
if (localStorage.getItem('dark_theme') === '1') {
  document.documentElement.classList.add('dark-theme');
  themeToggleBtn.textContent = 'â˜€ï¸';
}

// Draft restore â€” raw textarea
const savedDraftRaw = localStorage.getItem('draft_raw');
if (savedDraftRaw) rawEl.value = savedDraftRaw;

// Draft restore â€” processed output
const savedDraftOutput = localStorage.getItem('draft_output');
if (savedDraftOutput) {
  outputArea.innerHTML = savedDraftOutput;
  const savedStats = localStorage.getItem('draft_stats');
  if (savedStats) statsBarEl.textContent = savedStats;
  showScreen(screenOutput);
}

function showScreen(el) {
  SCREENS.forEach(s => s.classList.remove('active'));
  el.classList.add('active');
}

function updateProviderTag() {
  const isGemini = modelSelectEl.value.startsWith('gemini');
  providerTagEl.textContent = isGemini ? 'Google AI' : 'Anthropic';
}

// â”€â”€ THEME TOGGLE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
themeToggleBtn.addEventListener('click', () => {
  const isDark = document.documentElement.classList.toggle('dark-theme');
  themeToggleBtn.textContent = isDark ? 'â˜€ï¸' : 'ğŸŒ™';
  localStorage.setItem('dark_theme', isDark ? '1' : '0');
});

// â”€â”€ AUTO-SAVE DRAFT (RAW) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
rawEl.addEventListener('input', () => {
  localStorage.setItem('draft_raw', rawEl.value);
});

// â”€â”€ SETTINGS EVENTS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
settingsToggleBtn.addEventListener('click', () => {
  const open = settingsBarEl.classList.toggle('open');
  settingsToggleBtn.textContent = open ? 'âœ• ×¡×’×•×¨' : 'âš™ ×”×’×“×¨×•×ª';
});

toggleKeyBtn.addEventListener('click', () => {
  apiKeyEl.type = apiKeyEl.type === 'password' ? 'text' : 'password';
  toggleKeyBtn.textContent = apiKeyEl.type === 'password' ? '×”×¦×’' : '×”×¡×ª×¨';
});

toggleGeminiKeyBtn.addEventListener('click', () => {
  geminiKeyEl.type = geminiKeyEl.type === 'password' ? 'text' : 'password';
  toggleGeminiKeyBtn.textContent = geminiKeyEl.type === 'password' ? '×”×¦×’' : '×”×¡×ª×¨';
});

apiKeyEl.addEventListener('change', () => localStorage.setItem('anthropic_api_key', apiKeyEl.value));
geminiKeyEl.addEventListener('change', () => localStorage.setItem('gemini_api_key', geminiKeyEl.value));
modelSelectEl.addEventListener('change', () => {
  localStorage.setItem('selected_model', modelSelectEl.value);
  updateProviderTag();
});

// â”€â”€ FILE: TXT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
fileTxtEl.addEventListener('change', async e => {
  const f = e.target.files[0];
  if (!f) return;
  try {
    const txt = await f.text();
    rawEl.value = txt;
    fileInfoEl.textContent = `×§×•×‘×¥: ${f.name} â€” ×ª×•×•×™×: ${txt.length.toLocaleString()}`;
  } catch (err) {
    fileInfoEl.textContent = '×©×’×™××” ×‘×§×¨×™××ª ×”×§×•×‘×¥: ' + err.message;
  } finally { e.target.value = ''; }
});

// â”€â”€ FILE: WORD / PDF â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
fileOtherEl.addEventListener('change', async e => {
  const f = e.target.files[0];
  if (!f) return;
  const ext = (f.name.split('.').pop() || '').toLowerCase();
  fileInfoEl.textContent = `×˜×•×¢×Ÿ: ${f.name}...`;
  try {
    if (ext === 'txt') {
      const txt = await f.text();
      rawEl.value = txt;
      fileInfoEl.textContent = `×§×•×‘×¥: ${f.name} â€” ×ª×•×•×™×: ${txt.length.toLocaleString()}`;
    } else if (ext === 'docx') {
      const ab = await f.arrayBuffer();
      const txt = await extractDocxText(ab);
      if (txt && txt.length > 10) {
        rawEl.value = txt;
        fileInfoEl.textContent = `×§×•×‘×¥: ${f.name} â€” ×ª×•×•×™×: ${txt.length.toLocaleString()}`;
      } else {
        fileInfoEl.textContent = '×œ× ×”×¦×œ×—× ×• ×œ×—×œ×¥ ×˜×§×¡×˜ ×-DOCX. ×× × ×¤×ª×— ××ª ×”×§×•×‘×¥, ×”×¢×ª×§ ××ª ×”×˜×§×¡×˜ ×•×”×“×‘×§ ×™×“× ×™×ª.';
      }
    } else if (ext === 'pdf') {
      const ab = await f.arrayBuffer();
      const txt = await extractPdfText(ab);
      if (txt && txt.length > 10) {
        rawEl.value = txt;
        fileInfoEl.textContent = `×§×•×‘×¥: ${f.name} â€” ×ª×•×•×™×: ${txt.length.toLocaleString()}`;
      } else {
        fileInfoEl.textContent = '×œ× ×”×¦×œ×—× ×• ×œ×—×œ×¥ ×˜×§×¡×˜ ×-PDF. ×× × ×¤×ª×— ××ª ×”×§×•×‘×¥, ×”×¢×ª×§ ××ª ×”×˜×§×¡×˜ ×•×”×“×‘×§ ×™×“× ×™×ª.';
      }
    } else {
      fileInfoEl.textContent = '×¡×•×’ ×§×•×‘×¥ ×œ× × ×ª××š. ×× × ×”×©×ª××© ×‘-TXT, DOCX, ××• PDF.';
    }
  } catch (err) {
    fileInfoEl.textContent = '×©×’×™××”: ' + err.message;
  } finally { e.target.value = ''; }
});

// â”€â”€ IDENTIFY â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
identifyBtn.addEventListener('click', async () => {
  rawText = rawEl.value.trim();
  if (!rawText) { alert('×× × ×”×›× ×¡ ×ª××œ×™×œ ×œ×¤× ×™ ×”×–×™×”×•×™'); return; }

  // Validate the key relevant to the chosen model
  const model = modelSelectEl.value;
  if (model.startsWith('gemini')) {
    localStorage.setItem('gemini_api_key', geminiKeyEl.value);
    if (!geminiKeyEl.value.startsWith('AIza')) {
      alert('×× × ×”×›× ×¡ ××¤×ª×— Gemini API ×ª×§× ×™ (××ª×—×™×œ ×‘-AIza)'); return;
    }
  } else {
    localStorage.setItem('anthropic_api_key', apiKeyEl.value);
    if (!apiKeyEl.value.startsWith('sk-')) {
      alert('×× × ×”×›× ×¡ ××¤×ª×— Anthropic API ×ª×§× ×™ (××ª×—×™×œ ×‘-sk-)'); return;
    }
  }

  showScreen(screenIdent);
  detectedTypeEl.textContent = '×× ×ª×—...';
  recommendedPartsEl.textContent = '';
  identWarningEl.textContent = '';

  const sample = rawText.slice(0, 800);
  const prompt = sample + `\n\n×–×”×” ××ª ×¡×•×’ ×”×ª××œ×•×œ ××‘×™×Ÿ 4 ×”××¤×©×¨×•×™×•×ª (×”×¨×¦××” ××§×“××™×ª / ×™×©×™×‘×ª ×¢×‘×•×“×” / ×¨××™×•×Ÿ / ×¤×× ×œ). ×”×¢×¨×™×š ×‘×›××” ×—×œ×§×™× ×™×© ×œ×¢×‘×“. ×”×©×‘ ×‘×“×™×•×§ ×‘×¤×•×¨××˜:\n×¡×•×’: [×¡×•×’] | ×—×œ×§×™×: [××¡×¤×¨] | ×¡×™×‘×”: [××©×¤×˜ ××—×“]`;
  try {
    const resp = await callAPI(prompt, 300);
    const match = resp.match(/×¡×•×’:\s*\[?([^\]|]+)\]?\s*\|\s*×—×œ×§×™×:\s*\[?(\d+)\]?\s*\|\s*×¡×™×‘×”:\s*(.+)/i);
    if (match) {
      detectedTypeEl.textContent = `×¡×•×’ ××–×•×”×”: ${match[1].trim()}`;
      recommendedPartsEl.textContent = `×”××œ×¦×”: ${match[2]} ×—×œ×§×™× â€” ${match[3].trim()}`;
    } else {
      detectedTypeEl.textContent = '×–×•×”×” ×ª××œ×™×œ';
      recommendedPartsEl.textContent = resp.slice(0, 200);
    }
    const badRatio = (rawText.match(/\?\?\?|xxx|\[×œ× ×‘×¨×•×¨\]/gi) || []).length / Math.max(1, rawText.split(' ').length);
    if (badRatio > 0.15) identWarningEl.textContent = 'âš ï¸ ×©×™× ×œ×‘: ×—×œ×§ ××”×ª××œ×™×œ ×¢×©×•×™ ×œ×”×™×•×ª ×—×¡×¨ ××• ×œ× ×‘×¨×•×¨.';
  } catch (err) {
    detectedTypeEl.textContent = '×©×’×™××” ×‘×–×™×”×•×™: ' + err.message;
  }
});

// â”€â”€ CONFIRM & PROCESS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Text is ALWAYS fully extracted before this point (rawText = full document).
// Chunk size is generous: 30 000 chars for Anthropic, 80 000 for Gemini.
// Chunks are split only at natural semantic boundaries; overlap preserves context.
confirmStartBtn.addEventListener('click', async () => {
  const override = manualOverrideEl.value;
  const model = modelSelectEl.value;
  const maxChars = model.startsWith('gemini') ? 80000 : 30000;
  const chunks = semanticChunks(rawText, maxChars, 700);

  showScreen(screenProcess);
  progressBar.style.width = '0%';
  const results = [];
  const start = Date.now();
  let totalTokensEst = 0;

  startRotating([
    '×× ×ª×— ××‘× ×” ×”×ª××œ×•×œ...',
    '××¢×‘×“ ×ª×•×›×Ÿ ××§×“××™...',
    '××—×œ×¥ ××•×©×’×™× ××¨×›×–×™×™×...',
    '××‘×¦×¢ ×”×’×”×” ×œ×©×•× ×™×ª...',
    '××¡×™×™× ×¢×™×‘×•×“...'
  ]);

  for (let i = 0; i < chunks.length; i++) {
    partIndicatorEl.textContent = chunks.length > 1
      ? `××¢×‘×“ ×—×œ×§ ${i + 1} ××ª×•×š ${chunks.length}`
      : '';

    const typeHint = override !== 'auto' ? `×¡×•×’ ×§×‘×•×¢: ${override}\n\n` : '';

    // Fidelity instruction: mandatory when multi-chunk to preserve 100% of content
    const fidelityNote = chunks.length > 1
      ? `\n\n[×”× ×—×™×” ×œ×¢×™×‘×•×“ ×—×œ×§ ${i + 1}/${chunks.length}: ×¢×‘×“ ××ª ×›×œ ×”×ª×•×›×Ÿ ×©×œ ×§×˜×¢ ×–×” ×‘××œ×•××• ×”××•×—×œ×˜. ××™×Ÿ ×œ×ª××¦×ª, ××™×Ÿ ×œ×”×©××™×˜, ××™×Ÿ ×œ×“×œ×’ ×¢×œ × ×•×©× ×›×œ×©×”×•. ×›×œ ××•×©×’, ×›×œ ×“×•×’××”, ×›×œ × ×ª×•×Ÿ â€” ×—×™×™×‘×™× ×œ×”×•×¤×™×¢ ×‘×¤×œ×˜. × ××× ×•×ª ××œ××” ×©×œ 100% ×œ×˜×§×¡×˜ ×”××§×•×¨×™ ×”×™× ×”×“×¨×™×©×” ×”×¢×œ×™×•× ×”.]`
      : '';

    const userMsg = typeHint + chunks[i] + fidelityNote
      + '\n\n×¢×‘×“ ××ª ×”×˜×§×¡×˜ ×œ×¤×™ ×”× ×—×™×•×ª ×”××¢×¨×›×ª.'
      + ' ×”×—×–×¨ HTML ×‘×œ×‘×“: h1/h2/h3/p/strong. ××™×Ÿ Markdown. ××™×Ÿ ×”××¦××•×ª. ××™×Ÿ ×”×©××˜×•×ª.';

    try {
      const res = await callAPI(userMsg, 8000);
      results.push(res);
      totalTokensEst += Math.ceil((chunks[i].length + res.length) / 4);
      progressBar.style.width = Math.round(((i + 1) / chunks.length) * 100) + '%';
    } catch (err) {
      stopRotating();
      statusMsgEl.textContent = '×©×’×™××”: ' + err.message;
      return;
    }
  }

  stopRotating();
  progressBar.style.width = '100%';
  partIndicatorEl.textContent = '';
  statusMsgEl.textContent = '×”×•×©×œ×!';

  const elapsed = Math.round((Date.now() - start) / 1000);
  const finalHtml = results.join('\n');
  const wordCount = finalHtml.replace(/<[^>]+>/g, '').split(/\s+/).filter(Boolean).length;
  const statsText = `â± ×–××Ÿ ×¢×™×‘×•×“: ${elapsed} ×©× ×™×•×ª Â· ğŸ“ ××™×œ×™×: ${wordCount.toLocaleString()} Â· ğŸ”¢ ×˜×•×§× ×™× ××©×•×¢×¨×™×: ${totalTokensEst.toLocaleString()} Â· ××•×“×œ: ${model}`;
  statsBarEl.textContent = statsText;
  outputArea.innerHTML = finalHtml.replace(/\[([^\]]+)\]/g, '<span class="bracket">[$1]</span>');
  // Auto-save processed output and stats to localStorage
  localStorage.setItem('draft_output', outputArea.innerHTML);
  localStorage.setItem('draft_stats', statsText);
  showScreen(screenOutput);
});

// â”€â”€ OUTPUT ACTIONS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
resetBtn.addEventListener('click', () => {
  rawEl.value = '';
  fileInfoEl.textContent = '';
  showScreen(screenInput);
});

copyAllBtn.addEventListener('click', () => {
  navigator.clipboard.writeText(outputArea.innerText).then(() => {
    copyAllBtn.textContent = 'âœ“ ×”×•×¢×ª×§!';
    setTimeout(() => { copyAllBtn.textContent = '×”×¢×ª×§ ×”×›×œ'; }, 2000);
  });
});

exportTxtBtn.addEventListener('click', () => {
  const blob = new Blob([outputArea.innerText], { type: 'text/plain;charset=utf-8' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url; a.download = '×ª××œ×™×œ_××¢×•×‘×“.txt';
  document.body.appendChild(a); a.click();
  a.remove(); URL.revokeObjectURL(url);
});

exportDocBtn.addEventListener('click', () => {
  const html = `<!DOCTYPE html><html><head><meta charset="utf-8"><style>body{font-family:Arial,sans-serif;direction:rtl;line-height:1.7}h1,h2,h3{color:#261c0a}</style></head><body>${outputArea.innerHTML}</body></html>`;
  const blob = new Blob([html], { type: 'application/msword' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url; a.download = '×ª××œ×™×œ_××¢×•×‘×“.doc';
  document.body.appendChild(a); a.click();
  a.remove(); URL.revokeObjectURL(url);
});

newProcessBtn.addEventListener('click', () => {
  outputArea.innerHTML = '';
  statsBarEl.textContent = '';
  progressBar.style.width = '0%';
  rawEl.value = '';
  fileInfoEl.textContent = '';
  localStorage.removeItem('draft_raw');
  localStorage.removeItem('draft_output');
  localStorage.removeItem('draft_stats');
  showScreen(screenInput);
});

// â”€â”€ STATUS ROTATION â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function startRotating(msgs) {
  let i = 0;
  statusMsgEl.textContent = msgs[0];
  rotatingInterval = setInterval(() => { i = (i + 1) % msgs.length; statusMsgEl.textContent = msgs[i]; }, 2200);
}
function stopRotating() { clearInterval(rotatingInterval); }

// â”€â”€ API ROUTER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function callAPI(userContent, maxTokens = 8000) {
  return modelSelectEl.value.startsWith('gemini')
    ? callGemini(userContent, maxTokens)
    : callAnthropic(userContent, maxTokens);
}

// Anthropic Messages API (direct browser call)
async function callAnthropic(userContent, maxTokens) {
  const key = apiKeyEl.value.trim();
  if (!key) throw new Error('××™×Ÿ ××¤×ª×— Anthropic API');
  const body = {
    model: modelSelectEl.value,
    system: SYSTEM_PROMPT,
    messages: [{ role: 'user', content: userContent }],
    max_tokens: maxTokens
  };
  const resp = await fetch('https://api.anthropic.com/v1/messages', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'x-api-key': key,
      'anthropic-version': '2023-06-01',
      'anthropic-dangerous-direct-browser-calls': 'true'
    },
    body: JSON.stringify(body)
  });
  if (!resp.ok) {
    const err = await resp.text();
    throw new Error(`×©×’×™××ª Anthropic ${resp.status}: ${err.slice(0, 200)}`);
  }
  const j = await resp.json();
  return (j.content || []).map(c => c.text || '').join('');
}

// Google Gemini generateContent API (direct browser call with key in URL)
async function callGemini(userContent, maxTokens) {
  const key = geminiKeyEl.value.trim();
  if (!key) throw new Error('××™×Ÿ ××¤×ª×— Gemini API');
  const model = modelSelectEl.value;
  const url = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${key}`;
  const body = {
    system_instruction: { parts: [{ text: SYSTEM_PROMPT }] },
    contents: [{ role: 'user', parts: [{ text: userContent }] }],
    generationConfig: { maxOutputTokens: maxTokens, temperature: 0.3 }
  };
  const resp = await fetch(url, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(body)
  });
  if (!resp.ok) {
    const err = await resp.text();
    throw new Error(`×©×’×™××ª Gemini ${resp.status}: ${err.slice(0, 200)}`);
  }
  const j = await resp.json();
  return (j.candidates?.[0]?.content?.parts || []).map(p => p.text || '').join('');
}

// â”€â”€ SEMANTIC CHUNKING â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Splits ONLY when the text exceeds maxChars.
// Priority: paragraph break > single newline > sentence end > word boundary.
// Overlap of `overlap` chars is prepended to each subsequent chunk so the
// model has context across boundaries â€” no information is ever dropped.
function semanticChunks(text, maxChars = 30000, overlap = 700) {
  if (text.length <= maxChars) return [text];

  const chunks = [];
  let pos = 0;

  while (pos < text.length) {
    // If the remainder fits, take it whole
    if (pos + maxChars >= text.length) {
      chunks.push(text.slice(pos));
      break;
    }

    const seg = text.slice(pos, pos + maxChars);
    const minCut = Math.floor(maxChars * 0.4); // must consume at least 40%
    let cut = maxChars; // fallback: hard boundary

    // 1. Double newline (paragraph break) â€” cleanest split
    const dn = seg.lastIndexOf('\n\n');
    if (dn > minCut) {
      cut = dn + 2;
    } else {
      // 2. Single newline
      const sn = seg.lastIndexOf('\n');
      if (sn > minCut) {
        cut = sn + 1;
      } else {
        // 3. Sentence-ending punctuation (. ! ?) followed by space or newline
        let sentCut = -1;
        for (let i = seg.length - 1; i > minCut; i--) {
          if ('.!?'.includes(seg[i]) && i + 1 < seg.length && ' \n\r'.includes(seg[i + 1])) {
            sentCut = i + 2; break;
          }
        }
        if (sentCut > 0) {
          cut = sentCut;
        } else {
          // 4. Word boundary
          const sp = seg.lastIndexOf(' ');
          if (sp > minCut) cut = sp + 1;
        }
      }
    }

    chunks.push(seg.slice(0, cut));
    // Next chunk starts `overlap` chars before the cut point to preserve context
    pos = pos + cut - overlap;
  }

  return chunks;
}

// â”€â”€ DOCX TEXT EXTRACTION â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function extractDocxText(ab) {
  try {
    const data = new Uint8Array(ab);
    const dv = new DataView(ab);
    function findEOCD() {
      for (let i = data.length - 22; i >= 0; i--)
        if (dv.getUint32(i, true) === 0x06054b50) return i;
      return -1;
    }
    const eocd = findEOCD();
    if (eocd < 0) return null;
    const centralOffset = dv.getUint32(eocd + 16, true);
    const centralSize   = dv.getUint32(eocd + 12, true);
    let ptr = centralOffset;
    while (ptr < centralOffset + centralSize) {
      if (dv.getUint32(ptr, true) !== 0x02014b50) break;
      const fnLen = dv.getUint16(ptr + 28, true);
      const exLen = dv.getUint16(ptr + 30, true);
      const cmLen = dv.getUint16(ptr + 32, true);
      const lhOff = dv.getUint32(ptr + 42, true);
      const fname = new TextDecoder().decode(data.slice(ptr + 46, ptr + 46 + fnLen));
      if (fname === 'word/document.xml') {
        const lh = lhOff;
        const lfn = dv.getUint16(lh + 26, true);
        const lfx = dv.getUint16(lh + 28, true);
        const compSize  = dv.getUint32(lh + 18, true);
        const dataStart = lh + 30 + lfn + lfx;
        const compressed = data.slice(dataStart, dataStart + compSize);
        if (typeof DecompressionStream !== 'undefined') {
          const ds = new DecompressionStream('deflate-raw');
          const stream = new Blob([compressed]).stream().pipeThrough(ds);
          const text = await new Response(stream).text();
          const doc = new DOMParser().parseFromString(text, 'application/xml');
          return Array.from(doc.getElementsByTagName('w:t')).map(n => n.textContent).join(' ').replace(/\s+/g, ' ').trim();
        }
        return null;
      }
      ptr += 46 + fnLen + exLen + cmLen;
    }
    return null;
  } catch { return null; }
}

// â”€â”€ PDF TEXT EXTRACTION â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function extractPdfText(ab) {
  try {
    const bytes = new Uint8Array(ab);
    const latin1 = new TextDecoder('latin1').decode(bytes);

    // Try to decompress a Flate/zlib stream; tries both zlib-wrapped and raw deflate
    async function tryDeflate(raw) {
      if (typeof DecompressionStream === 'undefined') return null;
      for (const fmt of ['deflate', 'deflate-raw']) {
        try {
          const ds = new DecompressionStream(fmt);
          const writer = ds.writable.getWriter();
          const reader = ds.readable.getReader();
          writer.write(raw);
          writer.close();
          const parts = [];
          for (;;) { const { done, value } = await reader.read(); if (done) break; parts.push(value); }
          const total = parts.reduce((n, c) => n + c.length, 0);
          const out = new Uint8Array(total);
          let off = 0;
          for (const p of parts) { out.set(p, off); off += p.length; }
          return new TextDecoder('latin1').decode(out);
        } catch { /* try next format */ }
      }
      return null;
    }

    // Decode PDF literal string escapes: \n \r \t \b \f \\ \( \) \ddd (octal)
    function decodeLiteralStr(raw) {
      let out = '';
      for (let i = 0; i < raw.length; i++) {
        if (raw[i] !== '\\') { out += raw[i]; continue; }
        i++;
        const c = raw[i];
        if (c === 'n') out += '\n';
        else if (c === 'r') out += '\r';
        else if (c === 't') out += '\t';
        else if (c === 'b') out += '\b';
        else if (c === 'f') out += '\f';
        else if (c === '(' || c === ')' || c === '\\') out += c;
        else if (c >= '0' && c <= '7') {
          let oct = c;
          if (i + 1 < raw.length && raw[i + 1] >= '0' && raw[i + 1] <= '7') oct += raw[++i];
          if (i + 1 < raw.length && raw[i + 1] >= '0' && raw[i + 1] <= '7') oct += raw[++i];
          out += String.fromCharCode(parseInt(oct, 8));
        } else { out += c; }
      }
      return out;
    }

    // Decode PDF hex string <AABB...>
    function decodeHexStr(hex) {
      hex = hex.replace(/\s/g, '');
      if (hex.length % 2) hex += '0';
      let out = '';
      for (let i = 0; i < hex.length; i += 2)
        out += String.fromCharCode(parseInt(hex.slice(i, i + 2), 16));
      return out;
    }

    // Convert raw byte string to Unicode, handling UTF-16BE BOM (common in Hebrew PDFs)
    function toUnicode(s) {
      if (s.length >= 2 && s.charCodeAt(0) === 0xFE && s.charCodeAt(1) === 0xFF) {
        let u = '';
        for (let i = 2; i + 1 < s.length; i += 2)
          u += String.fromCodePoint((s.charCodeAt(i) << 8) | s.charCodeAt(i + 1));
        return u;
      }
      return s;
    }

    // Parse a decompressed PDF content stream and extract text from BT...ET blocks
    // Handles text operators: Tj, TJ, ' (quote), " (double-quote)
    // Handles both literal (...)  and hex <...> string types
    function extractTextFromContent(content) {
      const texts = [];
      const stack = [];
      let inBT = false;
      let i = 0;
      const len = content.length;
      const WS = new Set([0x00, 0x09, 0x0A, 0x0C, 0x0D, 0x20]);
      const DELIM = new Set(['(', ')', '<', '>', '[', ']', '{', '}', '/', '%']);

      function skip() { while (i < len && WS.has(content.charCodeAt(i))) i++; }

      function readPdfString() {
        if (content[i] === '(') {
          i++;
          let raw = ''; let depth = 1;
          while (i < len && depth > 0) {
            if (content[i] === '\\' && i + 1 < len) { raw += content[i] + content[i + 1]; i += 2; }
            else if (content[i] === '(') { depth++; raw += content[i++]; }
            else if (content[i] === ')') { depth--; if (depth > 0) raw += content[i]; i++; }
            else { raw += content[i++]; }
          }
          return toUnicode(decodeLiteralStr(raw));
        }
        if (content[i] === '<' && content[i + 1] !== '<') {
          i++;
          let hex = '';
          while (i < len && content[i] !== '>') hex += content[i++];
          if (i < len) i++;
          return toUnicode(decodeHexStr(hex));
        }
        return null;
      }

      while (i < len) {
        skip();
        if (i >= len) break;
        const ch = content[i];

        if (ch === '(' || (ch === '<' && content[i + 1] !== '<')) {
          const s = readPdfString();
          if (s !== null) stack.push({ t: 's', v: s });
          continue;
        }

        if (ch === '[') {
          i++;
          const arr = [];
          while (i < len) {
            skip();
            if (i >= len || content[i] === ']') break;
            if (content[i] === '(' || (content[i] === '<' && content[i + 1] !== '<')) {
              const s = readPdfString();
              if (s !== null) arr.push({ t: 's', v: s });
            } else {
              let tok = '';
              while (i < len && !WS.has(content.charCodeAt(i)) && !DELIM.has(content[i])) tok += content[i++];
              if (tok) arr.push({ t: 'n', v: tok });
            }
          }
          if (i < len) i++;
          stack.push({ t: 'a', v: arr });
          continue;
        }

        // Dictionary <<...>> â€” skip entirely
        if (ch === '<' && content[i + 1] === '<') {
          let depth = 1; i += 2;
          while (i < len && depth > 0) {
            if (content[i] === '<' && content[i + 1] === '<') { depth++; i += 2; }
            else if (content[i] === '>' && content[i + 1] === '>') { depth--; i += 2; }
            else i++;
          }
          stack.length = 0;
          continue;
        }

        if (ch === '%') { while (i < len && content[i] !== '\n' && content[i] !== '\r') i++; continue; }
        if (ch === '/') { while (i < len && !WS.has(content.charCodeAt(i)) && !DELIM.has(content[i])) i++; stack.length = 0; continue; }

        let word = '';
        while (i < len && !WS.has(content.charCodeAt(i)) && !DELIM.has(content[i])) word += content[i++];
        if (!word) { i++; continue; }

        if (!isNaN(word)) { stack.push({ t: 'n', v: word }); continue; }

        // PDF text-showing operators
        if (word === 'BT') { inBT = true; }
        else if (word === 'ET') { inBT = false; }
        else if (inBT) {
          const top = stack[stack.length - 1];
          if ((word === 'Tj' || word === "'") && top && top.t === 's' && top.v.trim()) {
            texts.push(top.v);
          } else if (word === '"' && top && top.t === 's' && top.v.trim()) {
            // Stack: [..., word-spacing, char-spacing, string]
            texts.push(top.v);
          } else if (word === 'TJ' && top && top.t === 'a') {
            for (const item of top.v) if (item.t === 's' && item.v.trim()) texts.push(item.v);
          }
        }
        stack.length = 0;
      }

      return texts.join('');
    }

    // Locate and process all streams in the PDF
    const allTexts = [];
    const streamRe = /stream[\r\n]+([\s\S]*?)[\r\n]endstream/g;
    let m;
    while ((m = streamRe.exec(latin1)) !== null) {
      const rawStr = m[1];
      const rawBytes = new Uint8Array(rawStr.length);
      for (let j = 0; j < rawStr.length; j++) rawBytes[j] = rawStr.charCodeAt(j) & 0xff;
      const decompressed = await tryDeflate(rawBytes);
      const content = decompressed ?? rawStr;
      if (!content.includes('BT')) continue;
      const text = extractTextFromContent(content);
      if (text && text.trim()) allTexts.push(text.trim());
    }

    // Fallback for simple uncompressed PDFs: naive literal-string scan
    if (allTexts.length === 0) {
      const fallbackRe = /\(([^)\\]{1,300})\)/g;
      let fm;
      while ((fm = fallbackRe.exec(latin1)) !== null) {
        const s = decodeLiteralStr(fm[1]);
        if (/[\u0590-\u05FFa-zA-Z]{2,}/.test(s)) allTexts.push(s);
      }
    }

    const result = allTexts.join(' ').replace(/\s+/g, ' ').trim();
    return result || null;
  } catch { return null; }
}
</script>
</body>
</html>
